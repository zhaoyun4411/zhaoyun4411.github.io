<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>CSAPP-网络编程 | 咸鱼站</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="网络应用随处可见。任何时候浏览Web、发送e-mail信息都是在使用网络应用程序。网络应用程序基本是基于相同的基本编程模型的，有着相似的整体逻辑结构，并且依赖相同的编程接口。 网络应用依赖许多在系统研究中已经学习过的概念。例如，进程、信号、字节顺序、内存映射以及动态内存分配，都扮演着重要的角色。还有一些新概念需要掌握。我们需要理解基本的*客户端-服务器编程模型，以及如何编写使用因特网提供的服务的客">
<meta property="og:type" content="article">
<meta property="og:title" content="CSAPP-网络编程">
<meta property="og:url" content="http://example.com/2022/06/24/CSAPP-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="咸鱼站">
<meta property="og:description" content="网络应用随处可见。任何时候浏览Web、发送e-mail信息都是在使用网络应用程序。网络应用程序基本是基于相同的基本编程模型的，有着相似的整体逻辑结构，并且依赖相同的编程接口。 网络应用依赖许多在系统研究中已经学习过的概念。例如，进程、信号、字节顺序、内存映射以及动态内存分配，都扮演着重要的角色。还有一些新概念需要掌握。我们需要理解基本的*客户端-服务器编程模型，以及如何编写使用因特网提供的服务的客">
<meta property="og:locale">
<meta property="article:published_time" content="2022-06-24T11:38:34.000Z">
<meta property="article:modified_time" content="2022-08-28T09:02:32.676Z">
<meta property="article:author" content="Yun Zhao">
<meta property="article:tag" content="CSAPP">
<meta property="article:tag" content="读书笔记">
<meta property="article:tag" content="CS">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="咸鱼站" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.2"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">咸鱼站</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-CSAPP-网络编程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/06/24/CSAPP-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" class="article-date">
  <time datetime="2022-06-24T11:38:34.000Z" itemprop="datePublished">2022-06-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      CSAPP-网络编程
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>网络应用随处可见。任何时候浏览Web、发送e-mail信息都是在使用网络应用程序。网络应用程序基本是基于相同的基本编程模型的，有着相似的整体逻辑结构，并且依赖相同的编程接口。</p>
<p>网络应用依赖许多在系统研究中已经学习过的概念。例如，进程、信号、字节顺序、内存映射以及动态内存分配，都扮演着重要的角色。还有一些新概念需要掌握。我们需要理解基本的*客户端-服务器编程模型，以及如何编写使用因特网提供的服务的客户端-服务器程序。</p>
<span id="more"></span>

<h3 id="1-客户端-服务器编程模型"><a href="#1-客户端-服务器编程模型" class="headerlink" title="1. 客户端-服务器编程模型"></a>1. 客户端-服务器编程模型</h3><p>每个网络应用都是基于<em>客户端-服务器模型</em>的。采用这个模型，一个应用是由一个服务器进程和一个或多个客户端进程组成的。服务器管理着某种<em>资源</em>，并且通过操作这种资源来为它的客户端提供某种<em>服务</em>。例如FTP服务器管理着一组磁盘文件，它会为客户端提供存储和检索服务。</p>
<p>客户端-服务器模型中的基本操作是<em>事务（transaction）</em>。一个客户端-服务器事务由以下四步组成：</p>
<ol>
<li>当一个客户端需要服务时，它向服务器发送一个请求，发起一个事务。</li>
<li>服务器收到请求后，解释它，并以适当的方式操作它的资源。</li>
<li>服务器给客户端发送一个响应，并等待下一个请求。</li>
<li>客户端收到响应并处理它。</li>
</ol>
<blockquote>
<p>客户端和服务器是进程，而不是常提到的机器或者主机。一台主机可以同时运行许多不同的客户端和服务器，而且一个客户端和服务器的事务可以在同一台或者是不同的主机上。</p>
</blockquote>
<h3 id="2-网络"><a href="#2-网络" class="headerlink" title="2. 网络"></a>2. 网络</h3><p>客户端和服务器通常运行在不同的主机上，并且通过<em>计算机网络</em>的硬件和软件资源来通信。这里将从程序员的视角给出一个切实可行的思维模型。</p>
<p>对于主机而言，网络只是一种I&#x2F;O设备，是数据源和数据接收方。</p>
<p>物理上，网络是一个按照地理远近组成的层次结构系统。最低层是LAN（local Area Network，局域网），在一个建筑或者校园范围内。</p>
<p>每个以太网适配器都有一个全球唯一的48位地址，它存储在这个适配器的非易失存储器上。一台主机可以发送一段位（称为帧（frame））到这个网段内的其他任何主机。每个帧包括一些固定数量的头部（header）位，用来标识此帧的源和目的地址以及此帧的长度，此后紧随着的就是数据位的<em>有效载荷（payload）</em>。每个主机适配器都能看到这个帧，但是只有目的主机实际读取它。</p>
<p>多个以太网段组成的局域网可以通过网桥的方式组成较大的局域网。</p>
<p>在更高级别中，多个不兼容的局域网可以通过叫做<em>路由器（router）</em>的特殊计算机连接起来，组成一个internet（互联网络）。路由器可以提供WAN（wide-Area Network，广域网）的网络示例。</p>
<blockquote>
<p>通常使用小写字母的internet描述互联网络这个一般概念，而用大写字母Internet来描述一种具体实现。</p>
</blockquote>
<p>互联网的一个重要的特性是，它能由采用完全不同和不兼容技术的各种局域网和广域网络组成。通过运行在每台主机和路由器上的协议软件，来消除不同网络之间的差异。这种协议必须提供两种基本能力：</p>
<ol>
<li><em>命名机制</em>。协议通过定义一种一致的主机地址格式消除这些差异。每个主机会被分配至少一个这种<em>互联网络地址（internet address）</em>。这个地址唯一的标识了这台主机。</li>
<li><em>传送机制</em>。互联网协议通过定义一种将数据位打包成不连续的片的统一方式，从而消除这些差异。一个包是由包头和有效载荷组成的。包头一般包括包的大小以及源主机和目的主机的地址，有效载荷包括从源主机发出的数据位。</li>
</ol>
<p>下面是一个例子说明这种数据的传送：</p>
<ol>
<li>运行在主机A上的客户端进行一个系统调用，从客户端的虚拟地址空间复制数据到内核缓冲区中。</li>
<li>主机A上的协议软件通过在数据前附加互联网络包头和LAN1帧头，创建一个LAN1的帧。互联网络的包头寻址到互联网主机B。LAN1帧头寻址到路由器。然后它传送此帧到适配器。（LAN1帧的有效载荷是一个互联网络包，而互联网络包的有效载荷是实际用户数据）</li>
<li>LAN1适配器复制该帧到网络上。</li>
<li>当此帧到达路由器，路由器的LAN1适配器从电缆上读取它，并将这帧数据传送到协议软件。</li>
<li>路由器从包头中提取目的地址，并用它作为路由表的索引，确定向哪里转发这个包。</li>
<li>路由器的LAN2适配器复制该帧到网络上。</li>
<li>当此帧到达主机B时，它的适配器从电缆上读到此帧，并将它传送到协议软件。</li>
<li>主机B上的协议软件剥离包头和帧头。将最终得到的数据复制到服务器的虚拟地址空间。</li>
</ol>
<h3 id="3-全球IP因特网"><a href="#3-全球IP因特网" class="headerlink" title="3. 全球IP因特网"></a>3. 全球IP因特网</h3><p>在全球IP因特网结构中，每台主机都运行实现TCP&#x2F;IP协议的软件。因特网的客户端和服务器混合使用<em>套接字接口</em>函数和Unix I&#x2F;O函数来进行通信。</p>
<p>TCP&#x2F;IP实际上是一个协议族，其中每一个都提供不同的功能。</p>
<p>IP协议提供基本的命名方法和递送机制，这种递送机制能够从一台因特网主机往其他主机发送包，也叫做*数据包(datagram)*。IP机制从某种意义上而言是不可靠的，因为，如果数据包在网络中丢失或者重复，它并不会试图恢复。UDP(Unreliable Datagram Protocol, 不可靠数据包协议)稍微扩展了IP协议，这样一来，包可以在进程间而不是在主机间传送。TCP是一个构建在IP之上的复杂协议，提供了进程间可靠的全双工(双向的)连接。</p>
<p>从程序员的角度来看，我们可以把因特网看作一个世界范围的主机集合，满足以下特性：</p>
<ul>
<li>主机集合被映射为一组32位的IP地址。</li>
<li>这组IP地址被映射成为一组称为<em>因特网域名（Internet domain name）</em>的标识符。</li>
<li>因特网主机上的进程能够通过<em>连接（connection）</em>和任何其他因特网主机上的进程通信。</li>
</ul>
<blockquote>
<p>IPv4 使用32位地址； IPv6使用128位地址。</p>
</blockquote>
<h4 id="3-1-IP地址"><a href="#3-1-IP地址" class="headerlink" title="3.1 IP地址"></a>3.1 IP地址</h4><p>一个IP地址是一个32位无符号整数。同时因为因特网主机有不同的主机字节顺序，TCP&#x2F;IP为任意数据项定义了统一的<em>网络字节顺序（network byte order）</em>(大端字节顺序)，即使主机字节顺序（host byte order）是小端法。Unix提供了下面这样的函数在网络和主机字节顺序间实现转换。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回按照网络字节顺序的值</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">htonl</span><span class="params">(<span class="type">uint32_t</span> hostlong)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">htons</span><span class="params">(<span class="type">uint32_t</span> hostshort)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回按照主机字节顺序的值</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ntonl</span><span class="params">(<span class="type">uint32_t</span> netlong)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">ntons</span><span class="params">(<span class="type">uint32_t</span> netshort)</span>;</span><br></pre></td></tr></table></figure>

<p>Linux系统中可以使用HOSTNAME命令来确定你自己的主机地址。</p>
<p>应用程序可以使用<code>inet_ptone</code>和<code>inet_ntop</code>函数来实现IP地址和点分十进制串之间的转换。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">inet_pton</span><span class="params">(AF_INET, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">void</span> *dst)</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">inet_ntop</span><span class="params">(AF_INET, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">char</span> *dst, <span class="type">socklen_t</span> size)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-因特网域名"><a href="#3-2-因特网域名" class="headerlink" title="3.2 因特网域名"></a>3.2 因特网域名</h4><p>因特网客户端和服务器互相通信的时候使用的是IP地址。然而对于人们而言，IP地址难以记住，所以因特网也定义了一组更加人性化的<em>域名（domain name）</em>，以及一种将域名映射到IP地址的机制。</p>
<p>一级域名包括’com’, ‘edu’, ‘gov’, ‘org’；二级域名包括‘baidu’，‘amazon’等等；三级域名包括‘www’， ‘cs’等等。</p>
<p>因特网定义了域名集合和IP地址集合之间的映射，直到1988年，这个映射都是通过一个叫做HOST.TXT的文本文件来手工维护的。从那以后，这个映射是通过分布在世界范围内的DNS（Domain Name System， 域名系统）来维护的。</p>
<p>可以使用Linux的<code>nslookup</code>程序来探究DNS映射的一些属性，如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">linux&gt; nslookup localhost</span><br><span class="line">Address: 127.0.0.1</span><br></pre></td></tr></table></figure>

<blockquote>
<p>最简单的情况是域名和IP之间是一一映射的；但是也可以多个域名映射到同一个IP地址；也可以一个域名映射到同一组的多个IP地址；最后也可以存在某些合法域名没有映射到任何IP地址。</p>
</blockquote>
<h4 id="3-3-因特网连接"><a href="#3-3-因特网连接" class="headerlink" title="3.3 因特网连接"></a>3.3 因特网连接</h4><p>因特网客户端和服务器通过在<em>连接</em>上发送和接收字节流来通信。从连接一对进程的意义上而言，连接是<em>点对点</em>的。从数据可以同时双向流动的角度来说，它是全双工且可靠的。</p>
<p>一个套接字是连接的一个端点。每个套接字都有相应的套接字地址，是由一个因特网地址和一个16位的整数端口组成，用“地址：端口”来表示。</p>
<p>当客户端发起一个连接请求时，客户端套接字地址中的端口是内核自动分配的，称为<em>临时端口（ephemeral port）</em>。然而，服务器套接字地址中的端口通常是某个<em>知名端口</em>，是和这个服务对应的。如Web服务器使用80号端口，电子邮件使用25号端口。每个具有知名端口的服务都有一个对应的知名的服务名。文件<code>/etc/services</code>包含了一张这台机器提供的知名的名字和端口之间的映射。</p>
<p>一个连接是由它两端的套接字地址唯一确定的。这对套接字地址叫做<em>套接字对（socket pair）</em>，由下列元组来表示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(cliaddr:cliport, servaddr:servport)</span><br></pre></td></tr></table></figure>

<h3 id="4-套接字接口"><a href="#4-套接字接口" class="headerlink" title="4. 套接字接口"></a>4. 套接字接口</h3><p>*套接字接口(socket interface)*是一组函数，它们和Unix I&#x2F;O函数结合起来，用于创建网络应用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">               +-  客户端             服务器</span><br><span class="line">               | getaddrinfo       getaddrinfo    -+</span><br><span class="line">               |     |                 |           |</span><br><span class="line">               |     V                 V           |</span><br><span class="line">               |   socket            socket        |</span><br><span class="line">               |     |                 |            &gt; open_listenfd</span><br><span class="line">               |     |                 V           |</span><br><span class="line">open_clientfd &lt;      |               bind          | </span><br><span class="line">               |     |                 |           | </span><br><span class="line">               |     |                 V           |</span><br><span class="line">               |     |              listen        -+</span><br><span class="line">               |     |                 |</span><br><span class="line">               |     V      连接请求     V</span><br><span class="line">               +- connect ---------&gt; accept   &lt;----+</span><br><span class="line">                     |                 |           |</span><br><span class="line">                     V                 V           |</span><br><span class="line">                rio_writen ------&gt; rio_readlineb   |    </span><br><span class="line">                     |                 |           |</span><br><span class="line">                     V                 V           |   等待来自</span><br><span class="line">              rio_readlineb &lt;-----  rio_writen     |   下一个客户端</span><br><span class="line">                     |                 |           |   的连接请求</span><br><span class="line">                     V        EOF      V           |</span><br><span class="line">                   close ---------&gt; rio_readlineb  |</span><br><span class="line">                                       |           |</span><br><span class="line">                                       V           |</span><br><span class="line">                                     close   ------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="4-1-套接字地址结构"><a href="#4-1-套接字地址结构" class="headerlink" title="4.1 套接字地址结构"></a>4.1 套接字地址结构</h4><p>从Linux内核的角度来看，一个套接字就是通信的一个端点。从Linux程序的角度来看，套接字就是一个有相应描述符的打开文件。</p>
<p>Linux 套接字存放在类型为<code>sockaddr_in</code>的数据结构中。</p>
<blockquote>
<p>这里<code>_in</code>后缀是互联网（internet）的缩写。</p>
</blockquote>
<h4 id="4-2-socket函数"><a href="#4-2-socket函数" class="headerlink" title="4.2 socket函数"></a>4.2 socket函数</h4><p>客户端和服务器使用<code>socket</code>函数来创建一个<code>套接字描述符(socket descriptor)</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br></pre></td></tr></table></figure>

<p>这里返回的描述符仅是部分打开的，还不能用于读写。如何完成打开套接字的工作，取决于我们是客户端还是服务器。</p>
<h4 id="4-3-connect函数"><a href="#4-3-connect函数" class="headerlink" title="4.3 connect函数"></a>4.3 connect函数</h4><p>客户端通过调用<code>connect</code>函数来建立和服务器的连接。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> clientfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure>

<p><code>connect</code>函数试图与套接字地址为<code>addr</code>的服务器建立一个因特网连接。connect函数会阻塞，一直到连接成功或者是发生错误。</p>
<h4 id="4-4-bind-x2F-listen-x2F-accept函数"><a href="#4-4-bind-x2F-listen-x2F-accept函数" class="headerlink" title="4.4 bind&#x2F;listen&#x2F;accept函数"></a>4.4 bind&#x2F;listen&#x2F;accept函数</h4><p><code>bind</code>,<code>listen</code>,<code>accept</code>函数，服务器用它们来和客户端建立连接。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure>
<p><code>bind</code>函数告诉内核将addr中的服务器套接字地址和套接字描述符sockfd联系起来。</p>
<p>客户端是发起连接请求的主动实体。服务器是等待来自客户端的连接请求的被动实体。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span>;</span><br></pre></td></tr></table></figure>
<p><code>listen</code>将sockfd从一个主动套接字转化成为一个<em>监听套接字（listening socket）</em>，该套接字可以接受来自客户端的连接请求。backlog参数表示排队未完成的连接请求数量。</p>
<p>服务器通过调用<code>accept</code>函数来等待来自客户端的连接请求。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> listenfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">int</span> *addrlen)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="4-5-主机和服务的转换"><a href="#4-5-主机和服务的转换" class="headerlink" title="4.5 主机和服务的转换"></a>4.5 主机和服务的转换</h4><p>Linux同时还提供了一些强大的函数（称为<code>getaddrinfo</code>和<code>getnameinfo</code>）实现二进制套接字地址结构和主机名，主机地址，服务名和端口号的字符串表示之间的互相转化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getaddrinfo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *host, <span class="type">const</span> <span class="type">char</span> *service,</span></span><br><span class="line"><span class="params">                <span class="type">const</span> <span class="keyword">struct</span> addrinfo *hints,</span></span><br><span class="line"><span class="params">                <span class="keyword">struct</span> addrinfo **result)</span>; <span class="comment">//返回：如果成功则为0，如果错误则为非0的错误代码</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeaddrinfo</span><span class="params">(<span class="keyword">struct</span> addrinfo *result)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">gai_strerror</span><span class="params">(<span class="type">int</span> errorcode)</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getnameinfo</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> socketaddr *sa, <span class="type">socklen_t</span> salen, </span></span><br><span class="line"><span class="params">                <span class="type">char</span> *host, <span class="type">size_t</span> hostlen, </span></span><br><span class="line"><span class="params">                <span class="type">char</span> *service, <span class="type">size_t</span> servlen, <span class="type">int</span> flags)</span>;<span class="comment">//返回：如果成功则为0，如果错误则为非0的错误代码</span></span><br></pre></td></tr></table></figure>

<h4 id="4-6-套接字接口的辅助函数"><a href="#4-6-套接字接口的辅助函数" class="headerlink" title="4.6 套接字接口的辅助函数"></a>4.6 套接字接口的辅助函数</h4><p>客户端还可以通过调用<code>open_clientfd</code>建立与服务器的连接。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">open_clientfd</span><span class="params">(<span class="type">char</span> *hostname, <span class="type">char</span> *port)</span>; <span class="comment">//成功则返回描述符，若出错则为-1</span></span><br></pre></td></tr></table></figure>

<p>服务器可以通过调用<code>open_listenfd</code>函数来创建一个监听描述符，并准备好连接请求。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">open_listenfd</span><span class="params">(<span class="type">char</span> *port)</span>; <span class="comment">//成功则返回描述符，若出错则为-1</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>EOF是由内核检测到的一种条件。应用程序在他接收到一个由read函数返回的零返回码的时候，它就会发出EOF条件。对于磁盘文件，出现这种情况通常的原因是文件位置超出文件长度。</p>
</blockquote>
<h3 id="5-Web服务器"><a href="#5-Web服务器" class="headerlink" title="5. Web服务器"></a>5. Web服务器</h3><p>Web客户端和服务器之间的交互的是一个基于文本的应用级协议，叫做HTTP。一个Web客户端（即浏览器）打开一个到服务器的因特网连接，并且请求某些内容。服务器响应所请求的内容，然后关闭连接。浏览器读取这些内容，并把它显示在屏幕上。</p>
<p>Web内容可以用一种叫做HTML的语言来编写。一个HTML程序页包含指令，它们告诉浏览器如何显示这页中的各种文本和图形对象。</p>
<p>对于Web客户端和服务器而言，内容是与一个MIME（Multipurpose Internet Mail Extensions, 多用途的网际邮件扩充协议）类型相关的字节序列。下面是一些常用的MIME类型。</p>
<table>
<thead>
<tr>
<th align="left">MIME类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">text&#x2F;html</td>
<td align="left">HTML页面</td>
</tr>
<tr>
<td align="left">text&#x2F;plain</td>
<td align="left">无格式文本</td>
</tr>
<tr>
<td align="left">application&#x2F;postscript</td>
<td align="left">Postscript文档</td>
</tr>
<tr>
<td align="left">image&#x2F;gif</td>
<td align="left">GIF格式编码的二进制图像</td>
</tr>
<tr>
<td align="left">image&#x2F;png</td>
<td align="left">PNG格式编码的二进制图像</td>
</tr>
<tr>
<td align="left">image&#x2F;jpeg</td>
<td align="left">JPEG格式编码的二进制图像</td>
</tr>
</tbody></table>
<p>Web服务器以两种不同的方式向客户端提供内容</p>
<ol>
<li>取一个磁盘文件，并将它的内容返回给客户端。这里的磁盘文件被称为<em>静态内容（static content）</em>，而返回文件给客户端的过程称为<em>服务静态内容(serving static content)</em>.</li>
<li>运行一个可执行文件，并将它的输出返回给客户端。运行时可执行文件产生的输出称为<em>动态内容（dynamic content）</em>。</li>
</ol>
<p>每条由Web服务器返回的内容都是和它管理的某个文件相关联的。这些文件中的每一个都有一个唯一的名字叫做URL（Universal Resource Locator, 通用资源定位符）。同时URL中可以使用<code>?</code>分隔文件名和参数，而且每个参数都可以使用<code>&amp;</code>字符分隔开。</p>
<p>HTTP事务主要有下面几种：</p>
<ol>
<li>HTTP请求。如GET，POST，OPTIONS等等。</li>
<li>HTTP响应。通常包括响应状态码。</li>
</ol>
<blockquote>
<p>当服务器接收到客户端请求后，会fork一个子进程来处理请求。 </p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/06/24/CSAPP-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" data-id="cl7d3spxo000eacowec19hbdk" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CS/" rel="tag">CS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CSAPP/" rel="tag">CSAPP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag">读书笔记</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/07/02/CSAPP-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          CSAPP-并发编程
        
      </div>
    </a>
  
  
    <a href="/2022/06/18/CSAPP-%E7%B3%BB%E7%BB%9F%E7%BA%A7IO/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">CSAPP-系统级IO</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Boot-process/" rel="tag">Boot process</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CAN/" rel="tag">CAN</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CS/" rel="tag">CS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSAPP/" rel="tag">CSAPP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Devops/" rel="tag">Devops</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Embedded-System/" rel="tag">Embedded System</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/" rel="tag">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IIS/" rel="tag">IIS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Intel/" rel="tag">Intel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Lisp/" rel="tag">Lisp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mac-OS/" rel="tag">Mac OS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Makefile/" rel="tag">Makefile</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Markdown/" rel="tag">Markdown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Modbus/" rel="tag">Modbus</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Modern-Robotics/" rel="tag">Modern Robotics</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Robotics/" rel="tag">Robotics</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SICP/" rel="tag">SICP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Stm32/" rel="tag">Stm32</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c/" rel="tag">c++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/freertos/" rel="tag">freertos</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/leetcode/" rel="tag">leetcode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sql/" rel="tag">sql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/timing/" rel="tag">timing</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vim/" rel="tag">vim</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%92%E8%81%94%E7%BD%91/" rel="tag">互联网</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%9A%E5%AE%A2/" rel="tag">博客</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C/" rel="tag">网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag">读书笔记</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Boot-process/" style="font-size: 10px;">Boot process</a> <a href="/tags/C/" style="font-size: 12.31px;">C</a> <a href="/tags/C/" style="font-size: 17.69px;">C++</a> <a href="/tags/CAN/" style="font-size: 10.77px;">CAN</a> <a href="/tags/CS/" style="font-size: 19.23px;">CS</a> <a href="/tags/CSAPP/" style="font-size: 17.69px;">CSAPP</a> <a href="/tags/Devops/" style="font-size: 10px;">Devops</a> <a href="/tags/Embedded-System/" style="font-size: 16.15px;">Embedded System</a> <a href="/tags/HTTP/" style="font-size: 16.92px;">HTTP</a> <a href="/tags/Hexo/" style="font-size: 10.77px;">Hexo</a> <a href="/tags/IIS/" style="font-size: 13.08px;">IIS</a> <a href="/tags/Intel/" style="font-size: 10px;">Intel</a> <a href="/tags/Linux/" style="font-size: 13.85px;">Linux</a> <a href="/tags/Lisp/" style="font-size: 14.62px;">Lisp</a> <a href="/tags/Mac-OS/" style="font-size: 10px;">Mac OS</a> <a href="/tags/Makefile/" style="font-size: 10px;">Makefile</a> <a href="/tags/Markdown/" style="font-size: 10px;">Markdown</a> <a href="/tags/Modbus/" style="font-size: 10.77px;">Modbus</a> <a href="/tags/Modern-Robotics/" style="font-size: 10px;">Modern Robotics</a> <a href="/tags/Robotics/" style="font-size: 10px;">Robotics</a> <a href="/tags/SICP/" style="font-size: 14.62px;">SICP</a> <a href="/tags/Stm32/" style="font-size: 12.31px;">Stm32</a> <a href="/tags/c/" style="font-size: 10px;">c++</a> <a href="/tags/freertos/" style="font-size: 10px;">freertos</a> <a href="/tags/git/" style="font-size: 12.31px;">git</a> <a href="/tags/leetcode/" style="font-size: 18.46px;">leetcode</a> <a href="/tags/sql/" style="font-size: 10px;">sql</a> <a href="/tags/timing/" style="font-size: 10px;">timing</a> <a href="/tags/vim/" style="font-size: 10px;">vim</a> <a href="/tags/%E4%BA%92%E8%81%94%E7%BD%91/" style="font-size: 13.08px;">互联网</a> <a href="/tags/%E5%8D%9A%E5%AE%A2/" style="font-size: 11.54px;">博客</a> <a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 15.38px;">网络</a> <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" style="font-size: 20px;">读书笔记</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/08/28/Intel-efi-%E7%9B%B8%E5%85%B3%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/">Intel-efi-相关启动流程解析</a>
          </li>
        
          <li>
            <a href="/2022/07/30/Modern-Robotics-%E4%BD%8D%E5%BD%A2%E7%A9%BA%E9%97%B4/">Modern-Robotics-位形空间</a>
          </li>
        
          <li>
            <a href="/2022/07/09/%E9%80%9A%E8%BF%87github-action%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/">通过github-action搭建博客自动部署</a>
          </li>
        
          <li>
            <a href="/2022/07/02/CSAPP-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">CSAPP-并发编程</a>
          </li>
        
          <li>
            <a href="/2022/06/24/CSAPP-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">CSAPP-网络编程</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 Yun Zhao<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>