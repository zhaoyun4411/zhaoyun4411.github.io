---
title: 函数式编程思想3-权责让渡
tags:
  - 函数式编程思想
  - 读书笔记
  - CS
---

软件开发的进步过程就是，我们构造一层又一层的抽象来处理（并隐藏）琐碎的细节。随着硬件能力的提高，我们将越来越多的任务转嫁给语言和运行时。

<!--more-->

函数式思维的好处之一，是能够将低层次的细节（如垃圾收集）的控制权移交给运行时，从而消弥了一大批注定会发生的程序错误。开发者可以一边享受最基本的抽象，比如内存，一边却会对更高层次的抽象感觉到突兀。然而不管层次的高低，抽象的目的总是一样的：让开发者从繁琐的运作细节里解脱出来，去解答问题中非重复性的那些方面。

这里将展示在函数式语言中，向语言和运行时让渡控制权的五种途径，让开发者抛开负累，投入到更有意义的问题中去。

### 1. 迭代让位于高阶函数

如果能用高阶函数把希望执行的操作表达出来，语言将会把操作安排得更加高效，甚至只要增加一行par修饰，就能够让操作并行化。

> 掌握和理解的抽象层次永远要比日常使用的抽象层次更深一层。只有当你掌握了背后的原理，才能把力量用在最正确的地方。

程序员的工作效率依赖于抽象，抽象隐藏了复杂的细节，只是有时会连同重要的考虑因素一起隐藏掉。

### 2. 闭包

闭包（closeure）是所有的函数式语言都具备的一项平常特性，可是相关的论述却常常充斥着晦涩乃至神秘的字眼。所谓的闭包，实际上是一种特殊的函数，它在暗地里绑定了函数内部引用的所有变量。换句话说，这种函数（或方法）把它引用的所有东西都放在一个上下文里“包”了起来。

闭包在生成的时候，会把引用的变量全部圈到代码块的作用域里，封闭、包围起来（故名闭包）。闭包的每个实例都有保有自己的一份变量取值，包括私有变量也是如此。

闭包通常被函数式语言和框架当作一种异地执行的机制，用来传递待执行的变换代码。

闭包这个名字来源于它创建封闭上下文的行为。虽然局部变量不是在代码块里面定义的，但是只要代码块引用了该变量，两者就被绑在了一起，这种联系在代码块实例的全部生命周期内一直保留。

从实现的角度来说，代码块实例从它被创建的一刻起，就持有其作用域内一切事物的封闭副本。当代码块实例被垃圾收集的时候，它持有的引用也同时被回收。

> 让语言去管理状态

闭包还是推迟执行原则的绝佳样板。我们将代码绑定到闭包之后，可以推迟到适当的时机再执行闭包。

命令式语言围绕状态来建立编程模型，参数传递是其典型特征。闭包作为一种对行为的建模，让我们把代码和上下文同时封装在单一结构，也就是闭包本身里面，像传统数据结构一样可以传递到其他位置，然后在恰当的时间和地点完成执行。

> 抓住上下文，而非状态。

### 3. 柯里化和函数的部分施用

柯里化（currying）和函数的部分施用(partial application)都是从数学里面借用过来的编程语言技法。这两种技法以不同的面目出现在各种类型的语言里面，在函数式语言中尤其普遍。柯里化和部分施用都有能力操纵函数或者方法的参数数目，一般是通过向一部分参数代入一个或者多个默认值的办法来实现的（这部分参数被称为“固定参数”）。

柯里化（currying）是指从一个多参数函数变成一连串单参数函数的变换。它描述的是变换的过程，不涉及变换之后对函数的调用。调用者可以决定对多少个参数实施变换，余下的部分将衍生成为一个参数较少的新函数。

部分施用(partial application)是指通过提前代入一部分参数值，使一个参数函数得以省略部分参数，从而转化为一个参数数目较少的函数。这种技法叫做“部分施用”，顾名思义，就是让函数先作用于其中一些参数，经过部分的求解，结果返回一个由余下参数构成签名的函数。

柯里化和部分施用都是在我们提供参数值之后，产生可以凭余下参数实施调用的一个函数。不同的地方在于，函数柯里化的结果是返回链条中的下一个函数，而部分施用是吧参数的取值绑定到用户操作中提供的具体值上面，因而产生一个“元数”（参数的数目较少的函数）。例如函数`process(x, y, z)`完全柯里化之后将变成为`process(x)(y)(z)`的形式。而部分施用将得到一个两个参数的函数：`process(y,z)`。

简单的理解柯里化就是转换函数参数为某些固定值。部分施用，如:

```
def volume = {h, w, l -> h*w*l}
def area = volume.curry(1)
def lengthPA = volume.curry(1, 1)  # 部分施用
def lengthC = volume.curry(1),curry(1)  #柯里化
```

### 4. 递归

### 5. stream和作业顺序重排

