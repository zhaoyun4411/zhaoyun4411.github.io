---
title: 函数式编程思想1-为什么
tags:
  - 函数式编程思想
  - 读书笔记
  - CS
date: 2022-11-26 21:56:21
---


函数编程思想在过去一般开发者的认知里面，函数式编程是一种仅仅存在于某些偏门语言里面学究气的概念。函数式编程的普及趋势，主要应该归功于因为纯函数，一等函数，高阶函数等特征迎合了人们对提高语法表现力和解决大规模并发问题的需要。

<!--more-->

这一章提供了概述和若干贯穿全书的思维转变的例子。

学习一种新的编程范式，困难并不在于掌握新的语言。真正考验人的，是怎么学会用另一种方式去思考。编程语言的进化正在朝着变得更加函数式发展。

### 1. 范式转变

计算机科学的进步经常是间歇式的，好的思路有的时候搁置数十年后才成为主流。

这里的讨论可以从两种风格的对比开始，尝试分别使用传统编程风格（命令式的循环）和函数式特征更明显的方式来解决同一问题。

1. 词频统计的传统方式实现。这里首先建立了一个“虚词（nonwords）”的集合。然后建立`wordFreq()`方法。方法首先建立一个Map结构来容纳由单词和词频组成的键值对，接着构件一个用来识别单词的正则表达式。接着遍历所有找到的单词，将首次遇到的单词添加到Map机构中，将重复遇到的单词的出现次数加一。

```java
public class Words {
    private Set<String> NON_WORDS = new HashSet<String>() {{
        add("the"); add("and"); add("of"); add("to"); add("a");
        add("i"); add("it"); add("in"); add("or"); add("is");
        add("d"); add("s"); add("as"); add("so"); add("but");
        add("be");
    }};

    public Map wordFreq(String words) {
        TreeMap<String, Integer> wordMap = new TreeMap<String, Integer>();
        while (m.find()) {
            String word = m.group().toLowerCase();
            if(! NON_WORDS.contains(word)) {
                if (wordMap.get(word) == null) {
                    wordMap.put(word, 1);
                }
                else {
                    wordMap.put(word, wordMap.get(word) + 1);
                }
            }
        }
        return wordMap;
    }
}
```

2. 词频统计的函数式方式实现。这里将正则表达式的匹配结果转换为stream，更方便后续执行互相独立的几项操作，将所有的单词条目转换为小写，滤除虚词，计算余下单词的词频。

```java
private List<String> regexToList(String words, String regex) {
    List wordList = new ArrayList<>();
    Matcger m = Pattern.compile(regex).matcher(words);
    while (m.find())
    wordList.add(m.group());
    return wordlist;
}

public Map wordFreq (String words) {
    TreeMap<String, Integer> wordMap = new TreeMap<>();
    regexToList(words, "\\w+").stream()
        .map(w -> w.toLowerCase())
        .filter(w -> !NON_WORDS.contains(w))
        .forEach(w -> wordMap.put(w, wordMap.getOrDefault(w, 0) + 1));

    return wordMap;
}

```

> 命令式的编程风格常常迫使我们出于性能考虑，将不同的任务*交织*起来，以便能够用一次循环来完成多个任务。而函数式编程使用`map` `filter`这些高阶函数将我们解放出来，让我们站在更高的抽象层次上去考虑问题，将问题看得更清楚。

### 2. 跟上语言发展的潮流

所有的主流语言都在进行函数式方面的扩展。

### 3. 把控制权让渡给语言/运行时

第四代编程语言（4GL）的卖点之一就是比C，Pascal等这些第三代语言（3GL）提供了更高层次的抽象。

随着时间的推移，开发者越来越多的将乏味单调的任务托付给语言和运行时。如同高级语言的垃圾回收机制一样，函数式编程语言让我们用高阶抽象从容取代基本的控制结构，也有着同样的意义。

### 4. 简洁

> 面向对象的编程通过封装不确定因素来使代码能被人理解；函数式编程通过尽量减少不确定因素来使代码能被人理解。

回想一下熟悉的封装，作用域，可见性等面向对象编程（OOP）构造，这些机制的存在意义，都是为了精细地控制谁能够感知状态和改变状态。而当涉及多线程的时候，对状态的控制就更加复杂了。这些机制就是属于“不确定因素(moving parts)”。大多数的函数式的语言在这个问题上采取了另一种做法，它们认为，与其建立种种机制来控制可变的状态，不如尽可能的消灭可变状态这个不确定因素。其立论的根据是这样的：假如语言不对外暴露那么多有出错可能的特性，那么开发者就不会那么容易犯错误。

在面向对象的编程语言中，重用的单元是类和类之间沟通用的消息，这些都可以用类图（class diagram）来表述。OOP的世界提倡开发者针对具体问题建立专门的数据结构，相关的专门操作以“方法”的形式附加在数据结构上。函数式编程语言实现重用的思路很不一样。函数式语言提倡在有限的几种关键数据结构（如list，set，map）上运用针对这些数据结构高度优化过的操作，以此构成基本运转机构。

比起一味的创建新的类结构体系，将封装的单元降低到函数级别，更有利于达到细粒度的，基础层面的重用。反面的例子是java中的json类，每一种都有自己定义的内部数据结构。

函数式程序员喜欢使用少数的核心数据结构，围绕它们去建立一套充分优化的运转机构。

面向对象程序员把所有的数据结构都封装成类，一方面压制了方法层面的重用，另一方面鼓励了大粒度的框架式的重用。

函数式的编程的程序构造更方便我们在比较细小的层面上重用代码。







